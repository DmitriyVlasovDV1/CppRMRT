<h1>Документация по рендеру:</h1>
______________________________________________________
<ul>
<li>Договоримся:</li>
пользователь == программист<br>
клиент == тот кто использует готовый продукт
<li>В общем (в хронологическом порядке с начала запуска):</li>
    <ul>
        <li>С начала, для дальнейшей работы, происходит инитиализация:</li>
            <ul>
                <li>GLFW - модуль который отвечает за создание окна и обработку все колбэков (изменение размеров окна, клавиатура и тп).</li>
                <li>GLEW - сам openGL, то есть создается контекст и привязывается к окну.</li>
                <li>Юниты - элементы программы которые позволяют пользователю взаимодействовать с рендером:</li>
                    <ul>
                        <li>Зачем? Почему это "удобно"?:</li>
                            <ul>
                                Есть класс рендера, который умеет управлять какими-то ресурсами,
                                значит ему надо предоставить элементы управления, чтобы пользователь мог этим
                                пользоваться - система юнитов - это система, которая позволяет пользователю создавать
                                объекты ресурсов рендера и, например, за ними никак не следить (они сами создадутся, нарисуются и удаляться,
                                самому пользователю не надо за этом следить), но в то же время пользоваться всеми методами
                                настройки этих самых ресурсов.<br>
                                <em>Пример:</em> примитив/модель - один из ресурсов рендера.
                                По задумке хранить указатель на этот ресурс пользователь может где угодно, но привязать к нему
                                реальные данные - только в юните, таким образом любой созданный примитив создастся, нарисуется и
                                удалится самим рендером, а не пользователем.<br><br>
                                <p>
                                    <strong>Итог:</strong> пользователь может "дергать" рендер только в юнитах,
                                    таким образом за юзером остается только "как этот ресурс должен себя вести"
                                </p>
                            </ul>
                        <li>Уточнение:</li>
                            <ul>
                                Инитиализируются только добавленные через main.cpp юниты - про все остальные рендер ничего не знает. Подробнее - позже.<br>
                                Далее происходит запуск бесконечного цикла обработки окна - как раз здесь и обрабатываются все колбэки,
                                считается наш локальный таймер (время работы программы + разница между (кадрами == итерации этого цикла)) и
                                происходит обработка всех юнитов (response) и их отрисовка (render). <strong>Собственно все</strong>, остается только момент,
                                когда окно закрывается - тогда вызовутся все деструкторы по порядку*.
                            </ul>
                    </ul>
            </ul>
        <li>Про ресурсы рендера: (Что это вообще такое?)</li>
            <ul>
                У нашего рендера на данный момент существуют следующие типы ресурсов: 
                    <ul>
                        <li>Буфера (вершинный буфер, буфер индексов, массиы "вершин", буфер для передачи данных на шейдера (ssbo)):</li>
                            <ul>
                                <li>Вершинный буфер:</li>
                                    <ul>
                                        <li>
                                            Буфер в котором храниться массив из нецелых чисел заданного формата, например:
                                            каждая вершина задается m числами и таких вершин n, то есть у нас будет создан вершинный буфер
                                            размера n внутри которого каждому кортежу из m чисел будет привязываться какой-то "смысл",
                                            то есть: формат = "v3v3v3" - 3 числа = первый параметр (например позиция точки в пространстве),
                                            следующие 3 числа = второй параметр (например цвет точки) и последние 3 числа = третий параметр
                                            (например нормаль к точке).<br><br>
                                            <strong>Итог:</strong> есть буфер на n точек, m чисел подряд описывают i-ю точку.
                                        </li>
                                    </ul>
                                <li>Буфер индексов:</li>
                                    <ul>
                                        <li>
                                            Массив натуральных чисел + {-1, 0} чисел которые описывают в каком порядке точки
                                            будут рисоваться (обычно в формате модели он уже указан, пользователю про эту тему можно и не знать).
                                        </li>
                                    </ul>
                                <li>Массив вершин:</li>
                                    <ul>
                                        <li>
                                            Буфер который в итоге будет рисоваться, то есть просто буфер который содержит в себе
                                            вершинный буфер и буфер индексов - <strong>все</strong>.
                                        </li>
                                    </ul>
                                <li>Буфер для передачи данных на шейдера (ssbo):</li>
                                    <ul>
                                        <li>
                                            Буфер которые позволяет передавать массив произвольных
                                            структур на шейдера, по фактам просто массив произвольного формата.
                                        </li>
                                    </ul>
                            </ul>
                        <li>Шейдера:</li>
                            <ul>
                                Микропрограммы, исполняемые на видеокарте.<br>
                                Шейдера загружаются и компилируются в самом начале один раз.
                            </ul>
                        <li>Примитивы/модели:</li>
                            <ul>
                                <li>Модель == массив примитивов.</li>
                                <li>Примитив:</li>
                                    <ul>
                                        <li>
                                            Это штука которая содержит все вышеперечисленные ресурсы, то есть это класс, который
                                            содержит массив вершин и шейдер.<br>
                                            Примитив/модель - то что пользователь будет использовать <strong>чаще всего</strong>.
                                        </li>
                                    </ul>
                            </ul>
                    </ul>
            </ul>
        <li>Так что же такое юнит?:</li>
            <ul>
                Юнит это виртуальный класс который внутри себя хранит все созданные внутри него объекты ресурсов.
                <li>Из виртуальных методов:</li>
                    <ul>
                        <li>init:</li>
                            <ul>
                                Место где можно все проинитиализировать внутри юнита (например создать примитив, шейдер и тп).
                                Как раз этот метод и есть инитиализация юнита (в целом юнит можно инитиализировать в его локальном
                                конструкторе, но это прям не надо, конструктор рекомендуется всегда указывать = default).<br><br>
                                <strong>Почему именно init, а не конструктор?</strong> - Данный метод нужен для того чтобы насильно вызывать инициализацию
                                того или иного юнита, тк она должна идти <strong>строго после</strong> инициализации рендера,
                                а сам рендер инициализируется, к сожалению, после вызова конструкторов всех юнитов.
                            </ul>
                        <li>response:</li>
                            <ul>
                                То что будет исполняться каждый кадр, например здесь можно как-то перемещать примитивы/модели
                                юнита и тп - этот метод == <strong>ваша фантазия</strong>.
                            </ul>
                        <li>деструктор:</li>
                            <ul>
                                Место где пользователь удаляет <strong>не ресурсы рендера</strong>: то есть если в init ты выделил память на
                                какой-то массив - удали его в деструкторе и тп - <strong>все</strong> ресурсы удалятся <strong>сами</strong>
                                (в целом можно их и удалять - ничего не сломается, но смысла в этом не будет).
                            </ul>
                    </ul>
            </ul>
        <li>"Порядку*" - что это? (а вот теперь ищи где это было):</li>
            <ul>
                Все ресурсы могут быть связаны (например: примитив содержит буфера), таким образом нам может быть важно в каком
                порядке их удалять - опять же, эту часть делает рендер внутри себя и делает это прекрасно, пользователь может
                об этом вообще не думать.
            </ul>
        <li>Мини-итог:</li>
            <ul>
                <strong>Юнит</strong> - связь пользователя и рендера, если проводить аналогию с UE/Unit - то юнит == level.
            </ul>
        <li>Про многопоточность:</li>
            <ul>
                Изначально предполагалось что мы <strong>не</strong> можем создавать больше чем одно окно.<br>
                На данный момент ничего не поменялось, НО пользователь в своих юнитах может спокойно использовать все что ему захочется
                (в том числе ::std::threads).
            </ul>
        <li>Про интерфейс:</li>
            <ul>
                <li>В целом:</li>
                    <ul>
                        Весь интерфейс это методы типа: set/get, add, create - обычно из назнания очевидно что они делают.
                    </ul>
                <li>Интерфейс в юнитах:</li>
                    <ul>
                        <li>create... (createPrimitive, createShader, ...):</li>
                            <ul>
                                Создает объект заданного типа, возвращает: указатель,
                                если был создан примитив/vertex array, id - во всех остальных случаях, тк с примитивом (или vertex array-ем)
                                можно еще что-то сделать, а вот шейдера и все остальные буфера - это что-то константное
                                (ну как минимум на данный момент).
                            </ul>
                        <li>set... (setVisibility):</li>
                            <ul>
                                Cеттер чего либо (на данный момент есть только один сеттер у самого юнита).
                            </ul>
                        <li>get... (getVisibility):</li>
                            <ul>
                                Геттер чего либо (смотри комментарии что же оно возвращает).<br>
                                В основном все get/set парные.
                            </ul>
                    </ul>
                <li>Интерфейс примитива:</li>
                    <ul>
                        <li>set...:</li>
                            <ul>
                                <li>setShaderProgram(uint):</li>
                                    <ul>
                                        Позволяет в произвольном месте программы поменять шейдер для отрисовки примитива.<br>
                                        Что же произойдет со старым шейдером? - Ничего, он на завершении программы удалиться как и все остальные шейдера,
                                        для этого у меня в кажом юните хранится отдельно вектора с каждым из видов объектов рендера.
                                    </ul>
                                <li>set/getRanderType(buffer::renderType/void):</li>
                                    <ul>
                                        Итерфейс позволяющий установить тип отрисовки примитива: либо полностью закрашено,
                                        либо каждый треугольник примитава выводится линией. 
                                    </ul>
                                <li>set/getVisibility:</li>
                                    <ul>
                                        Устанавливает флаг: выводится ли примитив на экран. 
                                    </ul>
                            </ul>
                        <li>addUniform(...):</li>
                            <ul>
                                Добавления юниформа на шейдер следующих типов: int/float/vec3/vec4. Юниформ - штука для передачи отдельных
                                переменных с кода на цпп на шейдер (например время или размеры окна).
                            </ul>
                    </ul>
                <li>Про модуль математики:</li>
                    <ul>
                        <li>Про матрицы в целом:</li>
                            <ul>
                                Все матрицы 4х4, на данный момент есть пара-тройка конструкторов (по дефолту инициализируется единичной матрицей).
                            </ul>
                        <li>Про методы класса матриц:</li>
                            <ul>
                                <li>Всякие операции (умножение, сложение, вычитание, копирование):</li>
                                    <ul>
                                        Очевидно что они делают.
                                    </ul>
                                <li>inverse/inverting:</li>
                                    <ul>
                                        Делает обратную матрицу, разница в том что inverting не меняет исходную матрицу,
                                        а inverse именно подменяет исходную на обратную у ней.
                                    </ul>
                                <li>transpose/transposing:</li>
                                    <ul>
                                        Делает транспонирование - разбиение так же как и у методов выше (один const другой нет).
                                    </ul>
                                <li>determinant:</li>
                                    <ul>
                                        Возвращает детерминант данной матрицы.
                                    </ul>
                                <li>getIdentity/getView/getOrthographic/getProjection:</li>
                                    <ul>
                                        Методы которые инитицализируют/возвращают матрицы указанные в названии.<br>
                                        Очень не хочется объяснять что делает каждая из этих матриц, среднему пользователю хватит единичной матрицы.
                                    </ul>
                                <li>rotate/rotateRad:</li>
                                    <ul>
                                        Матрица поворота относительно произвольной оси.
                                    </ul>
                                <li>rotateX/Y/Z/rotateX/Y/ZRad:</li>
                                    <ul>
                                        Матрица поворота относительно стандартных осей (X, Y, Z).
                                    </ul>
                                <li>scale:</li>
                                    <ul>
                                        Матрица scale-а.
                                    </ul>
                                <li>translate:</li>
                                    <ul>
                                        Матрица паралельного переноса.
                                    </ul>
                                <li>print:</li>
                                    <ul>
                                        Метод чтобы удобно напечатать матрицу в стандартный поток вывода.
                                    </ul>
                            </ul>
                        <li>Про методы класса векторов (vec3/vec4):</li>
                            <ul>
                                <li>Всякие операции:</li>
                                    <ul>
                                        Умножение скалярное (operator&)/векторное (operator%) для vec3, сложение, вычитание, копирование,
                                        умножение/деление на константу, получение длины вектора (operator!), взятие длины в квадрате (operator$),
                                        сравнения) - очевидно что они делают.
                                    </ul>
                                <li>normalize/normalizing:</li>
                                    <ul>
                                        Метод, приводящий вектор к единичной длине, один константный другой нет (аналогия inverse/inversing).
                                    </ul>
                                <li>min/max:</li>
                                    <ul>
                                        Методы min/max для векторов.
                                    </ul>
                                <li>toDword (только для vec3):</li>
                                    <ul>
                                        Метод, преобразующий вектор к unsigned long (4-х байтное число без знака).
                                    </ul>
                            </ul>
                    </ul>
            </ul>
    </ul>
</ul>