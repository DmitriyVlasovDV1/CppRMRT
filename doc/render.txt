Документация по рендеру:
    27.02.23:
        1) В общем (в хронологическом порядке с начала запуска):
            С начала, для дальнейшей работы, происходит инитиализация:
                а) glfw - модуль который отвечает за создание окна и обработку все колбэков
                    (изменение размеров окна, клавиатура и тп)
                б) glew - сам openGL, то есть создается контекст и привязывается к окну
                в) юниты - элементы программы которые позволяют пользователю взаимодействовать с рендером.
                    i) Зачем? Почему это "удобно"? - первое: есть класс рендера который умеет управлять какими-то ресурсами
                        значит ему надо предоставить элементы управления чтобы пользователь мог этим пользоваться -
                        система юнитов - это система которая позволяет пользователю создавать объекты ресурсов рендера и,
                        например, за ними никак не следить (они сами создадутся, нарисуются и удаляться,
                        самому пользователю не надо за этом следить), но в то же время пользоваться всеми методами
                        настройки этих самых ресурсов. Пример: примитив/модель - один из ресурсов рендера.
                        По задумке хранить указатель на этот ресурс пользователь может где угодно, но привязать к нему
                        реальные данные - только в юните, таким образом любой созданный примитив создастся, нарисуется и
                        удалится самим рендером, а не пользователем.
                       То есть итог: пользователь может "дергать" рендер только в юнитах,
                        таким образом за юзером остается только "как этот ресурс должен себя вести"
                    ii) Уточнение: инитиализируются только добавленные через main.cpp юниты - про все остальные рендер
                         ничего не знает. Подробнее - позже.
            Далее происходит запуск "бесконечного" цикла обработки окна - как раз здесь и обрабатываются все колбэки,
             считается наш локальный таймер (время работы программы + разница между (кадрами == итерации этого цикла)) и
             происходит обработка всех юнитов (response) и их отрисовка (render). Собственно все, остается только момент,
             когда окно закрывается - тогда вызовутся все деструкторы по *порядку.
        2) Про ресурсы: (Что это вообще такое?)
            У нашего рендера на данный момент (к 27.02.23) существуют следующие типы ресурсов:
                а) Буфера (вершинный буфер, буфер индексов, массиы "вершин", буфер для передачи данных на шейдера (ssbo))
                    i) Вершинный буфер: буфер в котором храниться массив из нецелых чисел заданного формата, например:
                        каждая вершина задается m числами и таких вершин n, то есть у нас будет создан вершинный буфер
                        размера n внутри которого каждому кортежу из m чисел будет привязываться какой-то "смысл",
                        то есть: формат = "v3v3v3" - 3 числа = первый параметр (например позиция точки в пространстве),
                        следующие 3 числа = второй параметр (например цвет точки) и последние 3 числа = третий параметр
                        (например нормаль к точке). Итог: есть буфер на n точек, m чисел подряд описывают i-ю точку.
                    ii) Буфер индексов: массив натуральных чисел + {-1, 0} чисел которые описывают в каком порядке точки
                         будут рисоваться (обычно в формате модели он уже указан, пользователю про эту тему можно и не знать).
                    iii) Массив вершин: буфер который в итоге будет рисоваться, то есть просто буфер который содержит в себе
                          вершинный буфер и буфер индексов - все.
                    iv) Буфер для передачи данных на шейдера (ssbo): буфер которые позволяет передавать массив произвольных
                           структур на шейдера, по фактам просто массив произвольного формата.
                б) Шейдера - микропрограммы, исполняемые на видеокарте. Шейдера загружаются и компилируются в самом начале
                    один раз.
                в) Примитивы/модели:
                    i) Модель == массив примитивов.
                    ii) Примитив: это штука которая содержит все вышеперечисленные ресурсы, то есть это класс, который
                         содержит массив вершин и шейдер. Примитив/модель - то что пользователь будет использовать чаще всего.
        3) Так что же такое юнит?:
            Юнит это "виртуальный" класс который внутри себя хранит все созданные внутри него объекты ресурсов.
            Из виртуальных методов:
                а) init: Место где можно все проинитиализировать внутри юнита (например создать примитив, шейдер и тп).
                    Как раз этот метод и есть инитиализация юнита (в целом юнит можно инитиализировать в его локальном
                    конструкторе, но это прям не надо, конструктор рекомендуется всегда указывать = default).
                б) response: То что будет исполняться каждый кадр, например здесь можно как-то перемещать примитивы/модели
                    юнита и тп - этот метод == ваша фантазия.
                в) деструктор: Место где пользователь удаляет НЕ РЕСУРСЫ РЕНДЕРА: то есть если в init ты выделил память на
                    какой-то массив - удали его в деструкторе и тп - ВСЕ ресурсы удалятся САМИ (в целом можно их и удалять -
                    ничего не сломается, но смысла в этом не будет).
        4) "*порядку" - что это?
            Все ресурсы могут быть связаны (например: примитив содержит буфера), таким образом нам может быть важно в каком
             порядке их удалять - опять же, эту часть делает рендер внутри себя и делает это прекрасно, пользователь может
             об этом вообще не думать.
        5) Мини-итог: Юнит - связь пользователя и рендера, если проводить аналогию с UE/Unit - то юнит == level.
        6) Комметарии/предложения - если можно в отдельный issue.
    09.03.23:
        1) Про многопоточность в моей части: изначально предполагалось что мы НЕ можем создавать больше чем одно окно.
            На данный момент ничего не поменялось, НО пользователь в своих юнитах может спокойно использовать все что ему захочется
            (в том числе ::std::threads).
В ЦЕЛОМ - весь интерфейс это методы типа: set/get, add, create - обычно из назнания очевидно что они делают.
        2) Часть про интерфейс в юнитах:
            а) Методы "создания" всех видов объектов рендера (примитивов, шейдеров и тп.):
                i) create... (createPrimitive, createShader, ...)  - создает объект заданного типа, возвращает: указатель,
                если был создан примитив/vertex array, id - во всех остальных случаях, тк с примитивом (или vertex array-ем)
                можно еще что-то сделать, а вот шейдера и все остальные буфера - это что-то константное (ну как минимум на данный момент)
            б) set... (setVisibility) - сеттер чего либо (на данный момент есть только один сеттер у самого юнита) | <-- в основном все
            в) get... (getVisibility) - геттер чего либо (смотри комментарии что же оно возвращает)                |     сеттеры и геттеры парные
        3) Часть про интерфейс примитива:
            а) set...
                i) setShaderProgram(uint) - позволяет в произвольном месте программы поменять шейдер для отрисовки примитива.
                    Что же произойдет со старым шейдером? - Ничего, он на завершении программы удалиться как и все остальные шейдера,
                    для этого у меня в кажом юните хранится отдельно вектора с каждым из видов объектов рендера.
                ii) set/getRanderType(buffer::renderType/void) - питерфейс позволяющий установить тип отрисовки примитива:
                    либо полностью закрашено, либо каждый треугольник примитава выводится линией.
                iii) set/getVisibility - устанавливает флаг: выводится ли примитив на экран.
            б) addUniform(...) - добавления юниформа на шейдер следующих типов: int/float/vec3/vec4. Юниформ - штука для передачи отдельных
                переменных с кода на цпп на шейдер (например время или размеры окна).
        4) Часть про модуль математики:
            а) Про матрицы в целом: у нас все матрицы 4х4, на данный момент есть пара-тройка конструкторов (по дефолту инициализируется единичной матрицей).
            б) Про методы класса матриц:
                i) Всякие операции (умножение, сложение, вычитание, копирование) - очевидно что они делают.
                ii) inverse/inverting - делает обратную матрицу, разница в том что inverting не меняет исходную матрицу, а inverse именно
                    подменяет исходную на обратную у ней.
                iii) transpose/transposing - делает транспонирование - разбиение так же как и у методов выше (один const другой нет)
                iv) determinant - возвращает детерминант данной матрицы.
                v) getIdentity/getView/getOrthographic/getProjection - методы которые инитицализируют матрицы указанные в названии.
                    Очень не хочется объяснять что делает каждая из этих матриц, среднему пользователю хватит единичной матрицы.
                vi) rotate/rotateRad - матрица поворота относительно произвольной оси.
                vii) rotateX/Y/Z/rotateX/Y/ZRad - матрица поворота относительно стандартных осей (X, Y, Z).
                viii) scale - матрица scale-а.
                ix) translate - матрица паралельного переноса.
                x) print - метод чтобы удобно напечатать матрицу в стандартный поток вывода.
            в) Про методы класса векторов (vec3/vec4):
                i) Всякие операции (умножение скалярное (operator&)/векторное (operator%) для vec3, сложение, вычитание, копирование,
                    умножение/деление на константу, получение длины вектора (operator!), взятие длины в квадрате (operator$),
                    сравнения) - очевидно что они делают.
                ii) normalize/normalizing - метод, приводящий вектор к единичной длине, один константный другой нет (аналогия inverse/inversing).
                iii) min/max - методы min/max для векторов.
                iv) toDword (только для vec3) - метод, преобразующий вектор к unsigned long (4-х байтное число без знака). 
